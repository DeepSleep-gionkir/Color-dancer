<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ğŸ‘» ì—ì½” ì í¼ (v4.0)</title>
    <style>
        /* --- ê¸°ë³¸ ë° ë ˆì´ì•„ì›ƒ --- */
        html, body {
            margin: 0;
            padding: 0;
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
            background-color: #000; /* ê²€ì€ìƒ‰ ë°°ê²½ */
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'DotGothic16', 'Courier New', monospace; /* í”½ì…€ í°íŠ¸ */
            touch-action: none; 
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            height: 100%;
            max-height: 800px;
            overflow: hidden;
            background-color: #2a2a3e; /* ë¬˜ì§€ ë°°ê²½ìƒ‰ */
            border: 2px solid #50507a;
        }

        #game-canvas {
            display: block;
            cursor: none;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
        }

        /* --- UI ì˜ì—­ --- */
        #ui-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            z-index: 5;
        }
        
        #gauge-container {
            width: 100%;
            height: 25px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #fff;
            border-radius: 0; /* í”½ì…€ ìŠ¤íƒ€ì¼ */
            overflow: hidden;
            display: none; 
        }

        #gauge-bar {
            width: 100%;
            height: 100%;
            background-color: #00FFFF; /* ì‹œì•ˆìƒ‰ */
            transition: width 0.1s linear;
        }

        #top-ui {
            position: absolute;
            top: 10px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 15px;
            box-sizing: border-box;
            font-size: 1.5em;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px #000;
            z-index: 5;
            pointer-events: none; 
        }
        
        /* ê²½í—˜ì¹˜ ë°” */
        #exp-bar {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 5px;
            background-color: #FFFF00; /* ë…¸ë€ìƒ‰ */
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.2s ease;
            z-index: 6;
        }

        /* --- ì˜¤ë²„ë ˆì´ ê³µí†µ --- */
        .overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(10, 10, 20, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            transition: opacity 0.3s ease, visibility 0.3s;
            visibility: hidden;
            opacity: 0;
            z-index: 10;
        }

        .overlay.visible {
            visibility: visible;
            opacity: 1;
        }
        
        /* ì˜¤ë²„ë ˆì´ ë‚´ë¶€ ì½˜í…ì¸  ë˜í¼ */
        #overlay-content-wrapper {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            width: 100%;
            height: 100%;
            max-height: 90%; /* ì½˜í…ì¸ ê°€ ë„ˆë¬´ ê¸¸ì–´ì§€ëŠ” ê²ƒ ë°©ì§€ */
            overflow: hidden; /* ë‚´ë¶€ ìŠ¤í¬ë¡¤ì€ #instructionsê°€ ë‹´ë‹¹ */
        }


        /* --- ì‹œì‘/ì¢…ë£Œ ì˜¤ë²„ë ˆì´ --- */
        #game-overlay h1 {
            color: #00FFFF; /* ë„¤ì˜¨ ì‹œì•ˆ */
            margin-bottom: 10px;
            flex-shrink: 0;
        }

        #game-overlay p {
            font-size: 1.1em;
            margin: 10px 0;
            flex-shrink: 0;
        }

        #start-button {
            padding: 15px 30px;
            font-size: 1.2em;
            font-weight: bold;
            color: #1a1a2e;
            background-color: #00FFFF;
            border: 2px solid #fff;
            border-radius: 0; /* í”½ì…€ ìŠ¤íƒ€ì¼ */
            cursor: pointer;
            box-shadow: 0 0 20px #00FFFF;
            margin-top: 20px;
            flex-shrink: 0;
        }

        #final-score {
            font-size: 1.5em;
            font-weight: bold;
            color: #FF00FF; /* ë„¤ì˜¨ ë§ˆì  íƒ€ */
            margin: 10px 0;
            flex-shrink: 0;
        }
        
        #best-time-display {
            font-size: 1.1em;
            color: #FFFF00;
            margin: 0;
        }
        
        /* ì •ë³´ ë²„íŠ¼ (ë³µêµ¬) */
        #info-button {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid #fff;
            color: white;
            font-size: 1.5em;
            font-weight: bold;
            cursor: pointer;
            z-index: 11;
        }
        
        /* ìƒì„¸ 'ê²Œì„ ë°©ë²•' UI (ë³µêµ¬) */
        #instructions {
            display: none; /* í‰ì†Œì—” ìˆ¨ê¹€ */
            flex-grow: 1; /* ë‚¨ëŠ” ê³µê°„ì„ ëª¨ë‘ ì°¨ì§€ */
            width: 100%;
            max-width: 400px; /* ê°€ë…ì„± ìœ„í•œ ìµœëŒ€ ë„ˆë¹„ */
            overflow-y: auto; /* *** ì—¬ê¸°ê°€ ìŠ¤í¬ë¡¤ì„ ë‹´ë‹¹ *** */
            text-align: left;
            padding: 10px;
            padding-right: 20px; /* ìŠ¤í¬ë¡¤ë°” ê³µê°„ */
            border-top: 1px solid #50507a;
            border-bottom: 1px solid #50507a;
        }
        
        #instructions h3 {
            color: #00FFFF;
            border-bottom: 1px solid #00FFFF;
            padding-bottom: 5px;
            margin-top: 15px;
            margin-bottom: 10px;
        }
        
        #instructions ul {
            padding-left: 20px;
            margin: 0 0 15px 0;
        }
        
        #instructions li {
            margin-bottom: 10px;
            line-height: 1.5;
        }
        
        #instructions b {
            color: #FFFF00; /* ë…¸ë€ìƒ‰ ê°•ì¡° */
        }
        
        #instructions code {
            background-color: #000;
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        /* --- ë ˆë²¨ ì—… ì˜¤ë²„ë ˆì´ --- */
        #level-up-overlay {
            justify-content: center;
            gap: 20px;
        }
        
        #level-up-title {
            color: #FFFF00;
            font-size: 2em;
            text-shadow: 2px 2px #000;
        }
        
        .upgrade-card {
            width: 80%;
            max-width: 300px;
            background-color: #1a1a2e;
            border: 3px solid #00FFFF;
            padding: 15px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .upgrade-card:hover {
            background-color: #3a3a5e;
        }
        
        .upgrade-card h3 {
            margin: 0 0 10px 0;
            color: #FFFF00;
        }
        
        .upgrade-card p {
            margin: 0;
            font-size: 1em;
            color: #eee;
        }

    </style>
    <link href="https://fonts.googleapis.com/css2?family=DotGothic16&display=swap" rel="stylesheet">
</head>
<body>

    <div id="game-container">
        
        <button id="info-button">?</button> <div id="top-ui">
            <div id="time-display">Time: 0</div> <div id="level">Lv. 1</div>
        </div>
        
        <div id="exp-bar"></div> <canvas id="game-canvas"></canvas>

        <div id="ui-container">
            <div id="gauge-container">
                <div id="gauge-bar"></div>
            </div>
        </div>
        
        <div id="game-overlay" class="overlay visible">
            <div id="overlay-content-wrapper">
                <h1>ğŸ‘» ì—ì½” ì í¼ ğŸ‘»</h1>
                <p id="best-time-display">Best Time: 0</p> <p id="overlay-message">
                    ì ì˜ ëª¸ì„ ë¹¼ì•—ì•„ ì‹¸ìš°ì„¸ìš”!<br>
                    ìˆ™ì£¼ê°€ íŒŒê´´ë˜ê¸° ì „ì— ë‹¤ìŒ ì ìœ¼ë¡œ 'ì í”„'í•˜ì„¸ìš”.
                </p>
                
                <div id="instructions">
                    <h3>ğŸ•¹ï¸ ì¡°ì‘ ë°©ë²• (Controls)</h3>
                    <h4>ğŸ–¥ï¸ PC (í‚¤ë³´ë“œ + ë§ˆìš°ìŠ¤)</h4>
                    <ul>
                        <li><b>ì´ë™:</b> ë§ˆìš°ìŠ¤ ì»¤ì„œë¥¼ ì›€ì§ì—¬ í•´ë‹¹ ë°©í–¥ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.</li>
                        <li><b>ëŒ€ì‹œ/ë¹™ì˜:</b> <code>ë§ˆìš°ìŠ¤ ì™¼ìª½ í´ë¦­</code>ì„ í•˜ì—¬ ê°€ì¥ ê°€ê¹Œìš´ ì ì—ê²Œ ëŒ€ì‹œ/ë¹™ì˜í•©ë‹ˆë‹¤.</li>
                    </ul>
                    <h4>ğŸ“± ëª¨ë°”ì¼ (í„°ì¹˜ìŠ¤í¬ë¦°)</h4>
                    <ul>
                        <li><b>ì´ë™:</b> í™”ë©´ ì•„ë¬´ ê³³ì´ë‚˜ <code>ì†ê°€ë½ìœ¼ë¡œ ë“œë˜ê·¸</code>í•˜ì—¬ í•´ë‹¹ ë°©í–¥ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.</li>
                        <li><b>ëŒ€ì‹œ/ë¹™ì˜:</b> í™”ë©´ ì•„ë¬´ ê³³ì´ë‚˜ <code>ì§§ê²Œ íƒ­(Tap)</code>í•˜ì—¬ ê°€ì¥ ê°€ê¹Œìš´ ì ì—ê²Œ ëŒ€ì‹œ/ë¹™ì˜í•©ë‹ˆë‹¤.</li>
                    </ul>
                    
                    <h3>1. ê¸°ë³¸ í”Œë ˆì´ ë°©ë²•</h3>
                    <ul>
                        <li>í”Œë ˆì´ì–´ëŠ” ê³µê²© ëŠ¥ë ¥ì´ ì—†ëŠ” <b>'ìœ ë ¹ (ğŸ”µ)'</b> ìƒíƒœë¡œ ì‹œì‘í•©ë‹ˆë‹¤. ìœ ë ¹ ìƒíƒœì—ì„œ ì ê³¼ ë‹¿ìœ¼ë©´ <b>ì¦‰ì‹œ ê²Œì„ ì˜¤ë²„</b>ì…ë‹ˆë‹¤.</li>
                        <li>'ëŒ€ì‹œ'ë¡œ ëª¬ìŠ¤í„°(ì˜ˆ: <code>â—»ï¸</code>)ì—ê²Œ ë‹¿ìœ¼ë©´ <b>'ë¹™ì˜'</b>í•©ë‹ˆë‹¤.</li>
                        <li>ë¹™ì˜ì— ì„±ê³µí•˜ë©´, í”Œë ˆì´ì–´ëŠ” <b>'í‘¸ë¥¸ìƒ‰ ìˆ™ì£¼ (â—»ï¸ğŸ”µ)'</b>ê°€ ë˜ì–´ ëª¬ìŠ¤í„°ë¥¼ ì¡°ì¢…í•˜ë©°, í•´ë‹¹ ëª¬ìŠ¤í„°ì˜ ê³ ìœ  ëŠ¥ë ¥ì´ <b>ìë™ìœ¼ë¡œ ë°œë™</b>ë©ë‹ˆë‹¤.</li>
                        <li>í•˜ë‹¨ì˜ <b>'ë¹™ì˜ ê²Œì´ì§€'</b>ëŠ” <b>ì§€ì†ì ìœ¼ë¡œ ê°ì†Œ</b>í•©ë‹ˆë‹¤. ê²Œì´ì§€ê°€ 0ì´ ë˜ë©´ ìˆ™ì£¼ê°€ íŒŒê´´ë˜ê³  ë‹¹ì‹ ì€ ì ì‹œ ë¬´ì  ìƒíƒœì˜ 'ìœ ë ¹'ì´ ë©ë‹ˆë‹¤.</li>
                        <li><b>(ì¤‘ìš”) ìˆ™ì£¼ í”¼ê²©:</b> ìˆ™ì£¼ ìƒíƒœì—ì„œ ì ê³¼ ë‹¿ìœ¼ë©´, ê²Œì´ì§€ê°€ ì¶”ê°€ë¡œ <b>ë” ë¹¨ë¦¬ ë‹³ìŠµë‹ˆë‹¤!</b></li>
                    </ul>
                    
                    <h3>2. ëª¬ìŠ¤í„°(ìˆ™ì£¼) íŠ¹ì§•</h3>
                    <ul>
                        <li><b>â—»ï¸ ìŠ¤ì¼ˆë ˆí†¤ (HP: 2):</b> [ë°¸ëŸ°ìŠ¤í˜•] ê°€ê¹Œìš´ ì ì—ê²Œ ë¼ˆë‹¤ê·€ë¥¼ ë˜ì§‘ë‹ˆë‹¤.</li>
                        <li><b>ğŸŸ© ì¢€ë¹„ (HP: 5):</b> [ê´‘ì—­/ë°©ì–´í˜•] ì£¼ë³€ì— 'ë¶€íŒ¨ ì˜¤ë¼'ë¥¼ ë°©ì¶œí•©ë‹ˆë‹¤. ê²Œì´ì§€ê°€ ë§¤ìš° ê¹ë‹ˆë‹¤.</li>
                        <li><b>ğŸŸª ë°•ì¥ (HP: 1):</b> [ê¸°ë™/ê´€í†µí˜•] ê°€ê¹Œìš´ ì ì—ê²Œ ë¹ ë¥¸ 'ì´ˆìŒíŒŒ'ë¥¼ ì©ë‹ˆë‹¤. ì´ë™ ì†ë„ê°€ ë¹ ë¦…ë‹ˆë‹¤.</li>
                        <li><b>ğŸ©¶ ê°€ê³ ì¼ (HP: 10):</b> [ë°©ì–´í˜•] <b>ê³µê²© ëŠ¥ë ¥ì´ ì—†ìŠµë‹ˆë‹¤.</b> ëŒ€ì‹  ë¹™ì˜ ê²Œì´ì§€ê°€ ì••ë„ì ìœ¼ë¡œ ê¸¸ì–´ 'ì•ˆì „ì§€ëŒ€' ì—­í• ì„ í•©ë‹ˆë‹¤.</li>
                    </ul>
                    
                    <h3>3. ê¸°ë¡</h3>
                    <ul>
                        <li>ì ì„ ì²˜ì¹˜í•˜ë©´ 'ì—ì½”(ğŸ’)'ë¥¼ ëª¨ì•„ ë ˆë²¨ ì—… í•©ë‹ˆë‹¤.</li>
                        <li>ì ìˆ˜ëŠ” ì—†ê³ , ì˜¤ì§ <b>'ë²„í‹´ ì‹œê°„'</b>ìœ¼ë¡œë§Œ ê¸°ë¡ì´ ì¸¡ì •ë©ë‹ˆë‹¤.</li>
                        <li>ìµœê³  ê¸°ë¡ì€ ë¸Œë¼ìš°ì €ì— ìë™ìœ¼ë¡œ ì €ì¥ë©ë‹ˆë‹¤.</li>
                    </ul>
                </div>
                
                <p id="final-score"></p>
                <button id="start-button">ì‹œì‘í•˜ê¸°</button>
            </div>
        </div>
        
        <div id="level-up-overlay" class="overlay">
            <h2 id="level-up-title">LEVEL UP!</h2>
            <div class="upgrade-card" data-upgrade="0">
                <h3></h3>
                <p></p>
            </div>
            <div class="upgrade-card" data-upgrade="1">
                <h3></h3>
                <p></p>
            </div>
            <div class="upgrade-card" data-upgrade="2">
                <h3></h3>
                <p></p>
            </div>
        </div>
        
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            
            // --- DOM ìš”ì†Œ ---
            const gameContainer = document.getElementById('game-container');
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            
            const gameOverlay = document.getElementById('game-overlay');
            const overlayContent = document.getElementById('overlay-content-wrapper');
            const startButton = document.getElementById('start-button');
            const finalScoreDisplay = document.getElementById('final-score');
            const bestTimeDisplay = document.getElementById('best-time-display');
            const infoButton = document.getElementById('info-button');
            const instructions = document.getElementById('instructions');
            const overlayMessage = document.getElementById('overlay-message');
            
            const timeDisplay = document.getElementById('time-display');
            const levelDisplay = document.getElementById('level');
            const expBar = document.getElementById('exp-bar');
            const gaugeContainer = document.getElementById('gauge-container');
            const gaugeBar = document.getElementById('gauge-bar');
            
            const levelUpOverlay = document.getElementById('level-up-overlay');
            const upgradeCards = document.querySelectorAll('.upgrade-card');

            // --- ìº”ë²„ìŠ¤ í¬ê¸° ---
            const VIEWPORT_WIDTH = gameContainer.clientWidth;
            const VIEWPORT_HEIGHT = gameContainer.clientHeight;
            const PIXEL_SCALE = 4; 
            canvas.width = VIEWPORT_WIDTH;
            canvas.height = VIEWPORT_HEIGHT;
            ctx.imageSmoothingEnabled = false;

            // --- ê²Œì„ ìƒíƒœ ë° ì„¤ì • ---
            let gameState = 'START'; // 'START', 'PLAYING', 'PAUSED', 'OVER'
            let gameTime = 0; // (Score -> Time)
            let gameLoopId = null;
            let frameCount = 0;
            let gameTimerInterval = null; // (ìƒˆë¡œ ì¶”ê°€)
            
            let spawnInterval = 180; // 3ì´ˆ
            let nextSpawnFrame = spawnInterval;
            let waveCount = 1;

            let player, enemies, projectiles, echoes;

            const BEST_TIME_KEY = 'echoJumperBestTime';

            // --- ë§ˆìš°ìŠ¤/í„°ì¹˜ ìœ„ì¹˜ ---
            let targetPos = { x: VIEWPORT_WIDTH / 2, y: VIEWPORT_HEIGHT / 2 };

            // --- ëª¬ìŠ¤í„°/í”Œë ˆì´ì–´/ì—…ê·¸ë ˆì´ë“œ ì •ì˜ (ìˆ˜ì •ë¨) ---
            const PLAYER_COLOR = '#00FFFF';
            const PLAYER_RADIUS = 4 * PIXEL_SCALE; // 8px
            const PLAYER_SPEED_WISP = 2.5;

            const MOB_PROPERTIES = {
                'skeleton': { gauge: 1000, attackType: 'bone', attackCooldown: 60, speed: 1.5, hp: 2, exp: 10, 
                    sprite: ['0110','1111','0110','0110','1001'], color: '#FFFFFF' },
                'zombie': { gauge: 1800, attackType: 'aura', attackCooldown: 10, speed: 0.8, hp: 5, exp: 20,
                    sprite: ['0110','1111','0110','1111','1001'], color: '#32CD32' },
                'bat': { gauge: 600, attackType: 'sonic', attackCooldown: 40, speed: 2.5, hp: 1, exp: 10, 
                    sprite: ['10101','01110','00100'], color: '#9400D3' }, 
                'gargoyle': { gauge: 4000, attackType: 'none', attackCooldown: 999, speed: 0.5, hp: 10, exp: 30,
                    sprite: ['01110','11111','11011','01110','01010'], color: '#888888' }
            };
            const MOB_TYPES = Object.keys(MOB_PROPERTIES);
            
            // ì—…ê·¸ë ˆì´ë“œ í’€
            const UPGRADE_POOL = [
                { id: 'gauge_1', title: 'ìˆ™ì£¼ ì•ˆì •í™” I', desc: 'ë¹™ì˜ ê²Œì´ì§€ ì´ëŸ‰ì´ 15% ì¦ê°€í•©ë‹ˆë‹¤.', apply: () => player.stats.maxGaugeMult += 0.15 },
                { id: 'wisp_speed_1', title: 'ìœ ë ¹ ê¸°ë™ë ¥ I', desc: 'ìœ ë ¹ ìƒíƒœì˜ ì´ë™ ì†ë„ê°€ 10% ì¦ê°€í•©ë‹ˆë‹¤.', apply: () => player.stats.wispSpeedMult += 0.1 },
                { id: 'jump_nova', title: 'ì†Œìš¸ ë…¸ë°”', desc: 'ìƒˆë¡œìš´ ìˆ™ì£¼ë¡œ \'ì í”„\'í•  ë•Œ ì£¼ë³€ì— í­ë°œì„ ì¼ìœ¼í‚µë‹ˆë‹¤.', apply: () => player.stats.jumpNova = true },
                { id: 'attack_speed_1', title: 'ê³µê²© ì†ë„ I', desc: 'ìˆ™ì£¼ì˜ ê³µê²© ì†ë„ê°€ 10% ì¦ê°€í•©ë‹ˆë‹¤.', apply: () => player.stats.attackSpeedMult += 0.1 },
                { id: 'aura_size_1', title: 'ë¶€íŒ¨ ì˜¤ë¼ í™•ì¥ I', desc: 'ì¢€ë¹„ì˜ ì˜¤ë¼ ë²”ìœ„ê°€ 15% ì¦ê°€í•©ë‹ˆë‹¤.', apply: () => player.stats.auraSizeMult += 0.15 },
                { id: 'bone_damage_1', title: 'ë‚ ì¹´ë¡œìš´ ë¼ˆ I', desc: 'ìŠ¤ì¼ˆë ˆí†¤ì˜ ë¼ˆ ë°ë¯¸ì§€ê°€ 1 ì¦ê°€í•©ë‹ˆë‹¤.', apply: () => player.stats.boneDamage += 1 },
                { id: 'sonic_damage_1', title: 'ì´ˆìŒíŒŒ ê°•í™” I', desc: 'ë°•ì¥ì˜ ì´ˆìŒíŒŒ ë°ë¯¸ì§€ê°€ 1 ì¦ê°€í•©ë‹ˆë‹¤.', apply: () => player.stats.sonicDamage += 1 },
            ];
            let currentUpgradeChoices = [];

            // --- í”½ì…€ ì•„íŠ¸ ê·¸ë¦¬ê¸° í•¨ìˆ˜ ---
            function drawPixelSprite(spriteData, x, y, colorTint) {
                const spriteHeight = spriteData.length;
                const spriteWidth = spriteData[0].length;
                const startX = Math.floor(x - (spriteWidth * PIXEL_SCALE) / 2);
                const startY = Math.floor(y - (spriteHeight * PIXEL_SCALE) / 2);
                ctx.fillStyle = colorTint;
                for (let r = 0; r < spriteHeight; r++) {
                    for (let c = 0; c < spriteWidth; c++) {
                        if (spriteData[r][c] === '1') {
                            ctx.fillRect(startX + c * PIXEL_SCALE, startY + r * PIXEL_SCALE, PIXEL_SCALE, PIXEL_SCALE);
                        }
                    }
                }
            }
            
            // --- í´ë˜ìŠ¤ ì •ì˜ ---
            class Player {
                constructor() { this.reset(); }
                reset() {
                    this.x = VIEWPORT_WIDTH / 2;
                    this.y = VIEWPORT_HEIGHT / 2;
                    this.radius = PLAYER_RADIUS;
                    this.state = 'WISP'; 
                    this.hostType = null;
                    this.gauge = 0;
                    this.maxGauge = 0;
                    this.speed = PLAYER_SPEED_WISP;
                    this.attackTimer = 0;
                    this.dashCooldown = 0;
                    this.unpossessTimer = 0;
                    this.level = 1;
                    this.experience = 0;
                    this.expToNextLevel = 100;
                    
                    this.stats = {
                        maxGaugeMult: 1.0,
                        wispSpeedMult: 1.0,
                        attackSpeedMult: 1.0,
                        jumpNova: false,
                        auraSizeMult: 1.0,
                        boneDamage: 1,
                        sonicDamage: 1,
                    };
                }

                draw() {
                    ctx.shadowBlur = 10; 
                    if (this.state === 'WISP' || this.state === 'UNPOSSESSING') {
                        ctx.fillStyle = PLAYER_COLOR;
                        ctx.shadowColor = PLAYER_COLOR;
                        if(this.unpossessTimer > 0 && frameCount % 10 < 5) {
                             ctx.globalAlpha = 0.5; 
                        }
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                    } else if (this.state === 'HOST') {
                        const spriteData = MOB_PROPERTIES[this.hostType].sprite;
                        drawPixelSprite(spriteData, this.x, this.y, PLAYER_COLOR);
                    }
                    ctx.shadowBlur = 0;
                }

                update() {
                    if (this.unpossessTimer > 0) {
                        this.unpossessTimer--;
                        if (this.unpossessTimer <= 0) this.state = 'WISP';
                    }
                    if (this.dashCooldown > 0) this.dashCooldown--;

                    // ì´ë™
                    const dx = targetPos.x - this.x;
                    const dy = targetPos.y - this.y;
                    const dist = Math.hypot(dx, dy);
                    const currentSpeed = (this.state === 'HOST') ? this.speed : PLAYER_SPEED_WISP * this.stats.wispSpeedMult;
                    if (dist > currentSpeed) {
                        this.x += (dx / dist) * currentSpeed;
                        this.y += (dy / dist) * currentSpeed;
                    }
                    
                    if (this.state === 'HOST') {
                        this.gauge--;
                        gaugeBar.style.width = `${Math.max(0, (this.gauge / this.maxGauge) * 100)}%`;
                        if (this.gauge <= 0) this.unpossess();
                        
                        this.attackTimer--;
                        if (this.attackTimer <= 0) this.attack();
                    }
                }
                
                attack() {
                    if (!this.hostType) return;
                    const props = MOB_PROPERTIES[this.hostType];
                    const attackCooldown = props.attackCooldown / (1.0 + this.stats.attackSpeedMult);
                    this.attackTimer = Math.max(10, attackCooldown); 
                    
                    const target = findNearestEnemy(this.x, this.y);
                    
                    switch (this.hostType) {
                        case 'skeleton':
                            if (target) {
                                projectiles.push(new Projectile(this.x, this.y, target, 'bone', this.stats.boneDamage));
                            }
                            break;
                        case 'zombie':
                            const auraRadius = 60 * this.stats.auraSizeMult;
                            enemies.forEach(enemy => {
                                if (Math.hypot(this.x - enemy.x, this.y - enemy.y) < auraRadius) {
                                    enemy.takeDamage(1); 
                                }
                            });
                            break;
                        case 'bat': 
                            if (target) {
                                projectiles.push(new Projectile(this.x, this.y, target, 'sonic', this.stats.sonicDamage));
                            }
                            break;
                    }
                }
                
                dash() {
                    if (this.dashCooldown > 0 || this.state === 'HOST') return; 
                    this.dashCooldown = 30; 
                    
                    let closestEnemy = findNearestEnemy(this.x, this.y, 150); 
                    
                    if (closestEnemy) {
                        this.possess(closestEnemy);
                    }
                }

                possess(enemy) {
                    if (this.stats.jumpNova) {
                        projectiles.push(new Projectile(this.x, this.y, null, 'explosion', 5));
                    }
                    
                    this.state = 'HOST';
                    this.hostType = enemy.type;
                    const props = MOB_PROPERTIES[this.hostType];
                    this.maxGauge = props.gauge * this.stats.maxGaugeMult;
                    this.gauge = this.maxGauge;
                    this.speed = props.speed;
                    this.x = enemy.x;
                    this.y = enemy.y;
                    targetPos.x = this.x; 
                    targetPos.y = this.y;
                    
                    gaugeContainer.style.display = 'block';
                    enemies = enemies.filter(e => e !== enemy);
                }

                unpossess() {
                    this.state = 'UNPOSSESSING'; 
                    this.unpossessTimer = 90; // 1.5ì´ˆ ë¬´ì 
                    this.hostType = null;
                    this.gauge = 0;
                    gaugeContainer.style.display = 'none';
                }
                
                takeGaugeDamage(amount) {
                    if (this.state !== 'HOST') return;
                    this.gauge -= amount;
                    // (TODO: í”¼ê²© ì‹œê° íš¨ê³¼)
                }
                
                collectExp(value) {
                    if (gameState !== 'PLAYING') return; 
                    this.experience += value;
                    if (this.experience >= this.expToNextLevel) {
                        this.levelUp();
                    }
                    expBar.style.transform = `scaleX(${this.experience / this.expToNextLevel})`;
                }
                
                levelUp() {
                    gameState = 'PAUSED'; 
                    this.level++;
                    this.experience -= this.expToNextLevel; 
                    this.expToNextLevel = Math.floor(this.expToNextLevel * 1.5);
                    
                    levelDisplay.textContent = `Lv. ${this.level}`;
                    expBar.style.transform = `scaleX(${Math.max(0, this.experience / this.expToNextLevel)})`;
                    
                    currentUpgradeChoices = getRandomUpgrades(3);
                    for (let i = 0; i < 3; i++) {
                        upgradeCards[i].querySelector('h3').textContent = currentUpgradeChoices[i].title;
                        upgradeCards[i].querySelector('p').textContent = currentUpgradeChoices[i].desc;
                    }
                    levelUpOverlay.classList.add('visible');
                    
                    if (this.experience >= this.expToNextLevel) {
                        this.experience = this.expToNextLevel - 1; 
                    }
                }
            }
            
            class Enemy {
                constructor(x, y, type) {
                    this.x = x;
                    this.y = y;
                    this.type = type;
                    this.props = MOB_PROPERTIES[type];
                    this.hp = this.props.hp;
                    this.radius = 8 * PIXEL_SCALE; 
                    this.color = this.props.color;
                    this.sprite = this.props.sprite;
                    this.speed = this.props.speed;
                }
                draw() {
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 10;
                    drawPixelSprite(this.sprite, this.x, this.y, this.color);
                    ctx.shadowBlur = 0;
                }
                update() {
                    const dx = player.x - this.x;
                    const dy = player.y - this.y;
                    const dist = Math.hypot(dx, dy);
                    if (dist > this.radius) { 
                        this.x += dx / dist * this.speed * 0.5; 
                        this.y += dy / dist * this.speed * 0.5;
                    }
                }
                takeDamage(amount) {
                    this.hp -= amount;
                    if (this.hp <= 0) {
                        this.die();
                    }
                }
                die() {
                    echoes.push(new Echo(this.x, this.y, this.props.exp));
                    enemies = enemies.filter(e => e !== this);
                }
            }
            
            class Projectile {
                constructor(x, y, target, type, damage) {
                    this.x = x;
                    this.y = y;
                    this.type = type;
                    this.damage = damage;
                    this.radius = 2 * PIXEL_SCALE;
                    this.speed = (type === 'sonic') ? 8 : 5;
                    this.life = 60; // 1ì´ˆ ìˆ˜ëª…
                    
                    if (type === 'explosion') {
                        this.radius = 50;
                        this.life = 10; // 0.16ì´ˆ
                    } else if (target) {
                        const dx = target.x - this.x;
                        const dy = target.y - this.y;
                        const dist = Math.hypot(dx, dy);
                        this.dx = (dx / dist) * this.speed;
                        this.dy = (dy / dist) * this.speed;
                    } else { 
                        this.dx = 0; this.dy = 0; 
                    }
                }
                draw() {
                    ctx.shadowBlur = 5;
                    switch(this.type) {
                        case 'bone':
                            ctx.fillStyle = '#FFFFFF';
                            ctx.shadowColor = '#FFFFFF';
                            ctx.fillRect(this.x - 2, this.y - 4, 4, 8); // 2x4 í”½ì…€
                            break;
                        case 'sonic':
                            ctx.fillStyle = '#9400D3';
                            ctx.shadowColor = '#9400D3';
                            ctx.fillRect(this.x - 4, this.y - 1, 8, 2); // 4x1 í”½ì…€
                            break;
                        case 'explosion':
                            ctx.strokeStyle = '#FFFF00';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.radius * (1 - this.life/10), 0, Math.PI*2);
                            ctx.stroke();
                            break;
                    }
                    ctx.shadowBlur = 0;
                }
                update() {
                    this.life--;
                    if (this.type !== 'explosion') {
                        this.x += this.dx;
                        this.y += this.dy;
                    }
                }
            }
            
            class Echo { // ê²½í—˜ì¹˜
                constructor(x, y, value) {
                    this.x = x;
                    this.y = y;
                    this.value = value;
                    this.radius = 3 * PIXEL_SCALE;
                    this.color = '#FFFF00'; // ë…¸ë€ìƒ‰
                    this.pickupRadius = 60;
                }
                draw() {
                    ctx.fillStyle = this.color;
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
                update() {
                    const dist = Math.hypot(player.x - this.x, player.y - this.y);
                    if (dist < this.pickupRadius) {
                        const dx = player.x - this.x;
                        const dy = player.y - this.y;
                        this.x += dx * 0.1;
                        this.y += dy * 0.1;
                    }
                }
            }

            // --- ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ---
            
            startButton.addEventListener('click', handleStartButton);
            
            // ì •ë³´ ë²„íŠ¼ (ìˆ˜ì •ë¨)
            infoButton.addEventListener('click', () => {
                if (gameState === 'PLAYING' || gameState === 'PAUSED') return;
                
                if (gameOverlay.dataset.mode === 'info') {
                    setupStartScreen(); // ì •ë³´ -> ì‹œì‘
                } else {
                    showInfo(); // ì‹œì‘ -> ì •ë³´
                }
            });
            
            // ì´ë™
            canvas.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                targetPos.x = e.clientX - rect.left;
                targetPos.y = e.clientY - rect.top;
            });
            canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                targetPos.x = e.touches[0].clientX - rect.left;
                targetPos.y = e.touches[0].clientY - rect.top;
            }, { passive: false });
            
            // ëŒ€ì‹œ/ë¹™ì˜
            canvas.addEventListener('mousedown', e => {
                if (gameState === 'PLAYING') player.dash();
            });
            canvas.addEventListener('touchstart', e => {
                if (e.target === canvas && gameState === 'PLAYING') {
                    player.dash();
                }
            }, { passive: false });
            
            // ì—…ê·¸ë ˆì´ë“œ ì¹´ë“œ í´ë¦­
            upgradeCards.forEach((card, index) => {
                card.addEventListener('click', () => {
                    if (gameState !== 'PAUSED') return;
                    currentUpgradeChoices[index].apply();
                    gameState = 'PLAYING';
                    levelUpOverlay.classList.remove('visible');
                    gameLoop(); // ë£¨í”„ ì¬ì‹œì‘
                });
            });


            // --- ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ---
            function findNearestEnemy(x, y, maxDist = Infinity) {
                let closestEnemy = null;
                let minDist = maxDist;
                enemies.forEach(enemy => {
                    const dist = Math.hypot(x - enemy.x, y - enemy.y);
                    if (dist < minDist) {
                        minDist = dist;
                        closestEnemy = enemy;
                    }
                });
                return closestEnemy;
            }
            
            function getRandomUpgrades(num) {
                const shuffled = [...UPGRADE_POOL].sort(() => 0.5 - Math.random());
                return shuffled.slice(0, num);
            }
            
            function getBestTime() {
                return parseInt(localStorage.getItem(BEST_TIME_KEY) || '0');
            }
            
            function saveBestTime(time) {
                const currentBest = getBestTime();
                if (time > currentBest) {
                    localStorage.setItem(BEST_TIME_KEY, time);
                    return true;
                }
                return false;
            }

            // --- í•µì‹¬ í•¨ìˆ˜ ---

            function handleStartButton() {
                if (gameOverlay.dataset.mode === 'info') {
                    setupStartScreen();
                } else {
                    startGame();
                }
            }
            
            function setupStartScreen(isGameOver = false) {
                gameState = 'START';
                
                // ìµœê³  ì‹œê°„ í‘œì‹œ (ìˆ˜ì •)
                bestTimeDisplay.textContent = `Best Time: ${getBestTime()}s`;
                
                if (isGameOver) {
                    finalScoreDisplay.textContent = `Time Survived: ${gameTime}s`;
                    if (saveBestTime(gameTime)) {
                        finalScoreDisplay.textContent += " (New Record!)";
                        bestTimeDisplay.textContent = `Best Time: ${gameTime}s`;
                    }
                    finalScoreDisplay.style.display = 'block';
                    startButton.textContent = 'ë‹¤ì‹œí•˜ê¸°';
                } else {
                    finalScoreDisplay.style.display = 'none';
                    startButton.textContent = 'ì‹œì‘í•˜ê¸°';
                }
                
                // ì •ë³´ì°½ ìˆ¨ê¸°ê³  ê¸°ë³¸ ë©”ì‹œì§€ í‘œì‹œ
                instructions.style.display = 'none';
                overlayMessage.style.display = 'block';
                gameOverlay.dataset.mode = 'start';
                gameOverlay.classList.add('visible');
            }
            
            function showInfo() {
                gameOverlay.dataset.mode = 'info';
                instructions.style.display = 'block'; 
                overlayMessage.style.display = 'none'; 
                finalScoreDisplay.style.display = 'none';
                startButton.textContent = 'ëŒì•„ê°€ê¸°';
                instructions.scrollTop = 0; // ìŠ¤í¬ë¡¤ ë§¨ ìœ„ë¡œ
            }

            function startGame() {
                gameTime = 0;
                frameCount = 0;
                waveCount = 1;
                spawnInterval = 180; 
                nextSpawnFrame = 0;
                
                timeDisplay.textContent = `Time: 0`;
                
                player = new Player();
                levelDisplay.textContent = `Lv. ${player.level}`;
                expBar.style.transform = `scaleX(0)`;
                
                enemies = [];
                projectiles = [];
                echoes = [];

                gameState = 'PLAYING';
                gameOverlay.classList.remove('visible');
                
                // 1ì´ˆë§ˆë‹¤ ì‹œê°„ ê°±ì‹  íƒ€ì´ë¨¸
                clearInterval(gameTimerInterval);
                gameTimerInterval = setInterval(() => {
                    if (gameState === 'PLAYING') {
                        gameTime++;
                        timeDisplay.textContent = `Time: ${gameTime}`;
                    }
                }, 1000);
                
                gameLoop(); // ë£¨í”„ ì‹œì‘
            }

            function endGame() {
                gameState = 'OVER';
                clearInterval(gameTimerInterval); // ì‹œê°„ íƒ€ì´ë¨¸ ì •ì§€
                cancelAnimationFrame(gameLoopId);
                setupStartScreen(true); 
            }
            
            // ìŠ¤í° ë¡œì§ (ìˆ˜ì •ë¨)
            function spawnEnemies() {
                frameCount++;
                
                // 10ì´ˆê¹Œì§€ëŠ” 3ì´ˆì— 1ë§ˆë¦¬
                if (frameCount < 600 && frameCount % 180 !== 0) {
                    if (frameCount === 60) { // 1ì´ˆ ë’¤ 1ë§ˆë¦¬ ìŠ¤í° (íŠœí† ë¦¬ì–¼ìš©)
                         enemies.push(new Enemy(VIEWPORT_WIDTH / 2, 50, 'skeleton'));
                    }
                    return;
                }
                
                if (frameCount > nextSpawnFrame) {
                    for(let i=0; i < waveCount; i++) {
                        const x = Math.random() < 0.5 ? -20 : VIEWPORT_WIDTH + 20;
                        const y = Math.random() * VIEWPORT_HEIGHT;
                        const type = MOB_TYPES[Math.floor(Math.random() * MOB_TYPES.length)];
                        enemies.push(new Enemy(x, y, type));
                    }
                    nextSpawnFrame = frameCount + spawnInterval;
                }
                
                // 20ì´ˆë§ˆë‹¤ ë‚œì´ë„ ìƒìŠ¹ (ìˆ˜ì •)
                if (frameCount % 1200 === 0 && frameCount > 0) { 
                    spawnInterval = Math.max(30, spawnInterval * 0.9); 
                    waveCount = Math.min(10, waveCount + 1); 
                }
            }
            
            function checkCollisions() {
                // 1. ìœ ë ¹ + ì  -> ê²Œì„ ì˜¤ë²„
                if (player.state === 'WISP') { 
                    for (const enemy of enemies) {
                        if (Math.hypot(player.x - enemy.x, player.y - enemy.y) < player.radius + enemy.radius) {
                            endGame();
                            return; 
                        }
                    }
                }
                
                // 2. ìˆ™ì£¼ + ì  -> ê²Œì´ì§€ ëŒ€ë¯¸ì§€ (ìƒˆë¡œ ì¶”ê°€)
                if (player.state === 'HOST') {
                    for (const enemy of enemies) {
                        if (Math.hypot(player.x - enemy.x, player.y - enemy.y) < player.radius + enemy.radius) {
                            player.takeGaugeDamage(50); // 50 í”„ë ˆì„ë§Œí¼ì˜ ê²Œì´ì§€ ì¦‰ì‹œ ê°ì†Œ
                        }
                    }
                }
                
                // 3. íˆ¬ì‚¬ì²´ + ì 
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const p = projectiles[i];
                    let projectileHit = false;
                    
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const e = enemies[j];
                        if (Math.hypot(p.x - e.x, p.y - e.y) < e.radius) {
                            e.takeDamage(p.damage);
                            projectileHit = true;
                        }
                    }
                    
                    if (projectileHit && p.type !== 'explosion') {
                        projectiles.splice(i, 1);
                    }
                }
                
                // 4. í”Œë ˆì´ì–´ + ì—ì½”
                for (let i = echoes.length - 1; i >= 0; i--) {
                    const e = echoes[i];
                    if (Math.hypot(player.x - e.x, player.y - e.y) < player.radius + e.radius + 10) {
                        player.collectExp(e.value);
                        echoes.splice(i, 1);
                    }
                }
            }

            // --- ë©”ì¸ ê²Œì„ ë£¨í”„ ---
            function gameLoop() {
                if (gameState !== 'PLAYING') {
                    cancelAnimationFrame(gameLoopId);
                    return;
                }
                gameLoopId = requestAnimationFrame(gameLoop);

                // 1. í´ë¦¬ì–´
                ctx.fillStyle = "#2a2a3e";
                ctx.fillRect(0, 0, VIEWPORT_WIDTH, VIEWPORT_HEIGHT);
                
                // 2. ìƒì„±
                spawnEnemies();
                
                // 3. ì—…ë°ì´íŠ¸
                player.update();
                enemies.forEach(e => e.update());
                projectiles.forEach(p => p.update());
                echoes.forEach(e => e.update());
                
                // 4. ì¶©ëŒ
                checkCollisions();
                
                // 5. ê·¸ë¦¬ê¸°
                projectiles.forEach(p => p.draw());
                echoes.forEach(e => e.draw());
                enemies.forEach(e => e.draw());
                player.draw(); 
                
                // 6. íˆ¬ì‚¬ì²´ ì œê±° (ìˆ˜ëª…)
                projectiles = projectiles.filter(p => p.life > 0);
            }
            
            // ì´ˆê¸° í™”ë©´ ì„¤ì •
            setupStartScreen();
        });
    </script>

</body>
</html>

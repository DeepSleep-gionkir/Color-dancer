<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ì»¬ëŸ¬ ëŒ„ì„œ</title>
    <style>
        /* --- ê¸°ë³¸ ë° ë ˆì´ì•„ì›ƒ --- */
        html, body {
            margin: 0;
            padding: 0;
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
            background-color: #111; /* ì–´ë‘ìš´ ë°°ê²½ */
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            touch-action: none; /* ëª¨ë°”ì¼ ìŠ¤í¬ë¡¤ ë°©ì§€ */
        }

        /* ìº”ë²„ìŠ¤ */
        #game-canvas {
            background-color: #000; /* í‘ë°± ì•…ë³´ ë°°ê²½ */
            border: 2px solid #555;
            cursor: none; /* ë§ˆìš°ìŠ¤ ì»¤ì„œ ìˆ¨ê¹€ */
        }

        /* --- ì‹œì‘/ì¢…ë£Œ ì˜¤ë²„ë ˆì´ --- */
        #game-overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            max-width: 500px;
            max-height: 800px;
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            transition: opacity 0.5s ease, visibility 0.5s;
            visibility: visible;
            opacity: 1;
            z-index: 10;
        }

        #game-overlay.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        #game-overlay h1 {
            color: #00FFFF; /* ë„¤ì˜¨ ì‹œì•ˆ */
            margin-bottom: 10px;
        }

        #game-overlay p {
            font-size: 1.1em;
            margin: 10px 20px;
        }

        #start-button {
            padding: 15px 30px;
            font-size: 1.2em;
            font-weight: bold;
            color: #000;
            background-color: #00FFFF;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 0 20px #00FFFF;
            margin-top: 20px;
        }

        #final-score {
            font-size: 1.5em;
            font-weight: bold;
            color: #FF00FF; /* ë„¤ì˜¨ ë§ˆì  íƒ€ */
            margin: 10px 0;
        }

    </style>
</head>
<body>

    <canvas id="game-canvas"></canvas>

    <div id="game-overlay" data-mode="start">
        <h1>ğŸ’  ì»¬ëŸ¬ ëŒ„ì„œ ğŸ’ </h1>
        <p>
            ì™¼ìª½ 'ì•ˆì „ì§€ëŒ€'ì—ì„œ ì¶œë°œí•˜ì—¬<br>
            ì•…ë³´ì— ë‹¹ì‹ ì˜ ê¶¤ì ì„ ê·¸ë¦¬ì„¸ìš”.<br><br>
            <b>'ë¶ˆí˜‘í™”ìŒ(ğŸ’¥)'</b>ì´ ë‹¹ì‹ ì˜ ëª¸ì´ë‚˜<br>
            ê·¸ë¦¬ê³  ìˆëŠ” <b>'ìƒ‰ì‹¤'</b>ì— ë‹¿ê¸° ì „ì—<br>
            ì•ˆì „ì§€ëŒ€ë¡œ ëŒì•„ì™€ ì˜ì—­ì„ ìƒ‰ì¹ í•˜ì„¸ìš”!
        </p>
        <p id="final-score"></p>
        <button id="start-button">ì‹œì‘í•˜ê¸°</button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            
            // --- DOM ìš”ì†Œ ---
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            const gameOverlay = document.getElementById('game-overlay');
            const startButton = document.getElementById('start-button');
            const finalScoreDisplay = document.getElementById('final-score');

            // --- ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì • ---
            const VIEWPORT_WIDTH = Math.min(window.innerWidth, 500);
            const VIEWPORT_HEIGHT = Math.min(window.innerHeight, 800);
            
            canvas.width = VIEWPORT_WIDTH;
            canvas.height = VIEWPORT_HEIGHT;

            // --- ê²Œì„ ìƒíƒœ ë° ì„¤ì • ---
            let gameState = 'start'; // 'start', 'playing', 'over'
            let score = 0;
            let lives = 3;
            let gameLoopId = null;

            const SAFE_ZONE_WIDTH = 20; // ì™¼ìª½ ì•ˆì „ì§€ëŒ€ ë„ˆë¹„
            const PLAYER_SIZE = 10;
            const ENEMY_SIZE = 15;
            const PLAYER_TRAIL_COLOR = "#00FFFF"; // ì‹œì•ˆìƒ‰
            const CAPTURED_AREA_COLOR = "rgba(0, 255, 255, 0.2)"; // ì˜…ì€ ì‹œì•ˆìƒ‰
            const ENEMY_COLOR = "#FF00FF"; // ë§ˆì  íƒ€ìƒ‰

            // --- ê²Œì„ ê°ì²´ ---
            let player = {
                x: SAFE_ZONE_WIDTH / 2,
                y: VIEWPORT_HEIGHT / 2,
                isDrawing: false,
                trail: [] // {x, y} ê°ì²´ì˜ ë°°ì—´
            };

            let enemies = [];
            let capturedAreas = []; // ì±„ì›Œì§„ ì˜ì—­ (í´ë¦¬ê³¤ ë°°ì—´)

            // --- ë§ˆìš°ìŠ¤/í„°ì¹˜ ìœ„ì¹˜ ---
            let mouse = {
                x: player.x,
                y: player.y
            };

            // --- ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ---
            const clickEvent = ('ontouchstart' in window) ? 'touchstart' : 'mousedown';
            startButton.addEventListener(clickEvent, startGame);
            
            // ë§ˆìš°ìŠ¤/í„°ì¹˜ ë¦¬ìŠ¤ë„ˆ
            canvas.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                mouse.x = e.clientX - rect.left;
                mouse.y = e.clientY - rect.top;
            });
            canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                mouse.x = e.touches[0].clientX - rect.left;
                mouse.y = e.touches[0].clientY - rect.top;
            }, { passive: false });


            // --- í•µì‹¬ í•¨ìˆ˜ ---

            function startGame() {
                // ê²Œì„ ë³€ìˆ˜ ì´ˆê¸°í™”
                score = 0;
                lives = 3;
                gameState = 'playing';
                player.x = SAFE_ZONE_WIDTH / 2;
                player.y = VIEWPORT_HEIGHT / 2;
                player.isDrawing = false;
                player.trail = [];
                capturedAreas = [];
                enemies = [];

                // ì  ìƒì„±
                spawnEnemy();
                spawnEnemy();

                gameOverlay.classList.add('hidden');
                
                // ë©”ì¸ ë£¨í”„ ì‹œì‘
                gameLoop();
            }

            function endGame() {
                gameState = 'over';
                cancelAnimationFrame(gameLoopId);
                
                finalScoreDisplay.textContent = `ìµœì¢… ì ìˆ˜: ${score}`;
                startButton.textContent = 'ë‹¤ì‹œí•˜ê¸°';
                gameOverlay.classList.remove('hidden');
            }
            
            function spawnEnemy() {
                enemies.push({
                    x: Math.random() * (VIEWPORT_WIDTH - SAFE_ZONE_WIDTH - ENEMY_SIZE) + SAFE_ZONE_WIDTH,
                    y: Math.random() * (VIEWPORT_HEIGHT - ENEMY_SIZE),
                    dx: (Math.random() < 0.5 ? 1 : -1) * (1 + Math.random()),
                    dy: (Math.random() < 0.5 ? 1 : -1) * (1 + Math.random()),
                });
            }

            function gameLoop() {
                if (gameState !== 'playing') return;

                update();
                draw();

                gameLoopId = requestAnimationFrame(gameLoop);
            }

            // --- ì—…ë°ì´íŠ¸ ë¡œì§ ---
            function update() {
                updatePlayer();
                updateEnemies();
                checkCollisions();
            }

            function updatePlayer() {
                // í”Œë ˆì´ì–´ë¥¼ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¡œ ë¶€ë“œëŸ½ê²Œ ì´ë™
                player.x += (mouse.x - player.x) * 0.2;
                player.y += (mouse.y - player.y) * 0.2;

                // ìº”ë²„ìŠ¤ ë°–ìœ¼ë¡œ ë‚˜ê°€ì§€ ì•Šë„ë¡
                player.x = Math.max(PLAYER_SIZE / 2, Math.min(VIEWPORT_WIDTH - PLAYER_SIZE / 2, player.x));
                player.y = Math.max(PLAYER_SIZE / 2, Math.min(VIEWPORT_HEIGHT - PLAYER_SIZE / 2, player.y));
                
                // ì•ˆì „ì§€ëŒ€ ìƒíƒœ í™•ì¸
                const wasDrawing = player.isDrawing;
                player.isDrawing = player.x > SAFE_ZONE_WIDTH + (PLAYER_SIZE / 2);

                if (player.isDrawing) {
                    // ê·¸ë¦¬ê³  ìˆëŠ” ì¤‘: íŠ¸ë ˆì¼ ì¶”ê°€
                    player.trail.push({ x: player.x, y: player.y });
                } else if (wasDrawing && !player.isDrawing) {
                    // ë°©ê¸ˆ ì•ˆì „ì§€ëŒ€ë¡œ ë³µê·€: ì˜ì—­ ìº¡ì²˜
                    captureArea();
                }
            }

            function updateEnemies() {
                enemies.forEach(enemy => {
                    enemy.x += enemy.dx;
                    enemy.y += enemy.dy;

                    // ë²½ê³¼ ì¶©ëŒ (ì•ˆì „ì§€ëŒ€ëŠ” ë¬´ì‹œ)
                    if (enemy.x < SAFE_ZONE_WIDTH || enemy.x > VIEWPORT_WIDTH - ENEMY_SIZE) {
                        enemy.dx *= -1;
                        enemy.x = Math.max(SAFE_ZONE_WIDTH, Math.min(VIEWPORT_WIDTH - ENEMY_SIZE, enemy.x));
                    }
                    if (enemy.y < 0 || enemy.y > VIEWPORT_HEIGHT - ENEMY_SIZE) {
                        enemy.dy *= -1;
                        enemy.y = Math.max(0, Math.min(VIEWPORT_HEIGHT - ENEMY_SIZE, enemy.y));
                    }
                });
            }

            function captureArea() {
                if (player.trail.length < 2) {
                    player.trail = [];
                    return; // ìº¡ì²˜í•  ì˜ì—­ì´ ì—†ìŒ
                }

                // í´ë¦¬ê³¤ ìƒì„±: íŠ¸ë ˆì¼ + ì•ˆì „ì§€ëŒ€ ë²½
                const newPolygon = [...player.trail];
                
                // íŠ¸ë ˆì¼ì˜ ë§ˆì§€ë§‰ ì ì—ì„œ ì•ˆì „ì§€ëŒ€ ë²½ê¹Œì§€
                newPolygon.push({ x: SAFE_ZONE_WIDTH, y: player.y });
                // íŠ¸ë ˆì¼ì˜ ì‹œì‘ì ì—ì„œ ì•ˆì „ì§€ëŒ€ ë²½ê¹Œì§€
                newPolygon.push({ x: SAFE_ZONE_WIDTH, y: player.trail[0].y });

                capturedAreas.push(newPolygon);
                
                // ì ìˆ˜ íšë“ (ê°„ë‹¨íˆ íŠ¸ë ˆì¼ ê¸¸ì´ ë¹„ë¡€)
                score += player.trail.length * 10;

                player.trail = [];
                
                // ë‚œì´ë„ ìƒìŠ¹: ì  ì¶”ê°€
                if (score > 10000 && enemies.length < 3) spawnEnemy();
                if (score > 30000 && enemies.length < 4) spawnEnemy();
            }
            
            function checkCollisions() {
                if (!player.isDrawing) return; // ì•ˆì „ì§€ëŒ€ì—ì„œëŠ” ë¬´ì 

                enemies.forEach(enemy => {
                    // 1. ì  vs í”Œë ˆì´ì–´ ì¶©ëŒ
                    if (isRectCollision(enemy, {x: player.x - PLAYER_SIZE/2, y: player.y - PLAYER_SIZE/2, width: PLAYER_SIZE, height: PLAYER_SIZE})) {
                        handleHit();
                        return;
                    }
                    
                    // 2. ì  vs íŠ¸ë ˆì¼ ì¶©ëŒ (ê°„ë‹¨í•˜ê²Œ)
                    // (ì„±ëŠ¥ì„ ìœ„í•´ 10ê°œë§ˆë‹¤ í•˜ë‚˜ì”© ì²´í¬)
                    for(let i = 0; i < player.trail.length; i += 10) {
                        const point = player.trail[i];
                        // ì  ì‚¬ê°í˜• ì•ˆì— íŠ¸ë ˆì¼ í¬ì¸íŠ¸ê°€ ë“¤ì–´ê°”ëŠ”ì§€
                        if (point.x >= enemy.x && point.x <= enemy.x + ENEMY_SIZE &&
                            point.y >= enemy.y && point.y <= enemy.y + ENEMY_SIZE) {
                            handleHit();
                            return;
                        }
                    }
                });
            }
            
            function handleHit() {
                lives--;
                player.isDrawing = false;
                player.trail = []; // íŠ¸ë ˆì¼ ë¦¬ì…‹
                player.x = SAFE_ZONE_WIDTH / 2; // ì•ˆì „ì§€ëŒ€ë¡œ ë³µê·€
                mouse.x = player.x; // ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë„ ë¦¬ì…‹
                
                // ê°„ë‹¨í•œ í™”ë©´ ê¹œë¹¡ì„ íš¨ê³¼
                canvas.style.backgroundColor = "#FF0000";
                setTimeout(() => { canvas.style.backgroundColor = "#000"; }, 100);

                if (lives <= 0) {
                    endGame();
                }
            }
            
            function isRectCollision(rect1, rect2) {
                // rect1 = enemy (x,y,width,height)
                // rect2 = player (x,y,width,height)
                const r1 = { ...rect1, width: ENEMY_SIZE, height: ENEMY_SIZE };
                return (
                    r1.x < rect2.x + rect2.width &&
                    r1.x + r1.width > rect2.x &&
                    r1.y < rect2.y + rect2.height &&
                    r1.y + r1.height > rect2.y
                );
            }

            // --- ê·¸ë¦¬ê¸° ë¡œì§ ---
            function draw() {
                // 1. ë°°ê²½ í´ë¦¬ì–´ (ì˜¤ì„ ì§€ ëŠë‚Œ)
                ctx.fillStyle = "#000";
                ctx.fillRect(0, 0, VIEWPORT_WIDTH, VIEWPORT_HEIGHT);
                
                ctx.strokeStyle = "#333";
                ctx.lineWidth = 1;
                for(let i=0.3; i < 0.8; i += 0.1) {
                    ctx.beginPath();
                    ctx.moveTo(0, VIEWPORT_HEIGHT * i);
                    ctx.lineTo(VIEWPORT_WIDTH, VIEWPORT_HEIGHT * i);
                    ctx.stroke();
                }

                // 2. ì•ˆì „ì§€ëŒ€
                ctx.fillStyle = "#222";
                ctx.fillRect(0, 0, SAFE_ZONE_WIDTH, VIEWPORT_HEIGHT);

                // 3. ìº¡ì²˜ëœ ì˜ì—­
                ctx.fillStyle = CAPTURED_AREA_COLOR;
                capturedAreas.forEach(polygon => {
                    ctx.beginPath();
                    ctx.moveTo(polygon[0].x, polygon[0].y);
                    polygon.forEach(point => ctx.lineTo(point.x, point.y));
                    ctx.closePath();
                    ctx.fill();
                });

                // 4. ê·¸ë¦¬ëŠ” ì¤‘ì¸ íŠ¸ë ˆì¼ (ìƒ‰ì‹¤)
                if (player.isDrawing && player.trail.length > 1) {
                    ctx.strokeStyle = PLAYER_TRAIL_COLOR;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(player.trail[0].x, player.trail[0].y);
                    player.trail.forEach(point => ctx.lineTo(point.x, point.y));
                    ctx.stroke();
                }

                // 5. í”Œë ˆì´ì–´ (ë¦¬ë“¬ì˜ ì •ë ¹ ğŸ’ )
                ctx.fillStyle = PLAYER_TRAIL_COLOR;
                ctx.beginPath();
                ctx.moveTo(player.x, player.y - PLAYER_SIZE / 2); // ìœ„ìª½ ê¼­ì§“ì 
                ctx.lineTo(player.x + PLAYER_SIZE / 2, player.y);
                ctx.lineTo(player.x, player.y + PLAYER_SIZE / 2);
                ctx.lineTo(player.x - PLAYER_SIZE / 2, player.y);
                ctx.closePath();
                ctx.fill();

                // 6. ì  (ë¶ˆí˜‘í™”ìŒ ğŸ’¥)
                ctx.fillStyle = ENEMY_COLOR;
                enemies.forEach(enemy => {
                    // ctx.fillRect(enemy.x, enemy.y, ENEMY_SIZE, ENEMY_SIZE);
                    // í…ìŠ¤íŠ¸(ì´ëª¨ì§€)ë¡œ ê·¸ë¦¬ê¸°
                    ctx.font = `${ENEMY_SIZE}px Arial`;
                    ctx.fillText('ğŸ’¥', enemy.x, enemy.y + ENEMY_SIZE);
                });

                // 7. UI (ì ìˆ˜, ëª©ìˆ¨)
                ctx.fillStyle = "white";
                ctx.font = "20px Arial";
                ctx.textAlign = "right";
                ctx.fillText(`Score: ${score}`, VIEWPORT_WIDTH - 20, 30);
                
                ctx.textAlign = "left";
                ctx.fillText(`Lives: ${'ğŸ’ '.repeat(lives)}`, 20, 30);
            }
        });
    </script>

</body>
</html>

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ğŸ‘» ì—ì½” ì í¼ (v2.0)</title>
    <style>
        /* --- ê¸°ë³¸ ë° ë ˆì´ì•„ì›ƒ --- */
        html, body {
            margin: 0;
            padding: 0;
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
            background-color: #1a1a2e; /* ì–´ë‘ìš´ ë‚¨ìƒ‰ ë°¤í•˜ëŠ˜ */
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            touch-action: none; /* ëª¨ë°”ì¼ ìŠ¤í¬ë¡¤/ì¤Œ ë°©ì§€ */
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            height: 100%;
            max-height: 800px;
            overflow: hidden;
            background-color: #2a2a3e; /* ë¬˜ì§€ ë°°ê²½ìƒ‰ */
            border: 2px solid #50507a;
        }

        #game-canvas {
            display: block;
            cursor: none;
        }

        /* --- UI ì˜ì—­ --- */
        #ui-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            z-index: 5;
        }
        
        #gauge-container {
            width: 100%;
            height: 25px;
            background-color: rgba(0, 0, 0, 0.3);
            border: 2px solid #fff;
            border-radius: 15px;
            overflow: hidden;
            display: none; /* ìœ ë ¹ ìƒíƒœì¼ ë• ìˆ¨ê¹€ */
        }

        #gauge-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #00FFFF, #00BFFF);
            transition: width 0.1s linear;
        }

        #top-ui {
            position: absolute;
            top: 10px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 15px;
            box-sizing: border-box;
            font-size: 1.5em;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 5px #000;
            z-index: 5;
            pointer-events: none; /* UIê°€ í„°ì¹˜/í´ë¦­ ë°©í•´í•˜ì§€ ì•Šë„ë¡ */
        }

        /* --- ì˜¤ë²„ë ˆì´ ë° ì •ë³´ì°½ (ëŒ€í­ ìˆ˜ì •) --- */
        #game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(10, 10, 20, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            transition: opacity 0.5s ease, visibility 0.5s;
            visibility: visible;
            opacity: 1;
            z-index: 10;
        }

        #game-overlay.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }
        
        /* ì˜¤ë²„ë ˆì´ ë‚´ë¶€ ì½˜í…ì¸  ë˜í¼ */
        #overlay-content-wrapper {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            width: 100%;
            height: 100%;
            max-height: 90%; /* ì½˜í…ì¸ ê°€ ë„ˆë¬´ ê¸¸ì–´ì§€ëŠ” ê²ƒ ë°©ì§€ */
            overflow: hidden; /* ë‚´ë¶€ ìŠ¤í¬ë¡¤ì€ #instructionsê°€ ë‹´ë‹¹ */
        }

        #overlay-content-wrapper h1 {
            color: #00FFFF; /* ë„¤ì˜¨ ì‹œì•ˆ */
            margin-top: 0;
            margin-bottom: 10px;
            flex-shrink: 0;
        }

        #overlay-content-wrapper p {
            font-size: 1.1em;
            margin: 10px 0;
            flex-shrink: 0;
        }

        #start-button {
            padding: 15px 30px;
            font-size: 1.2em;
            font-weight: bold;
            color: #1a1a2e;
            background-color: #00FFFF;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 0 20px #00FFFF;
            margin-top: 20px;
            flex-shrink: 0;
        }

        #final-score {
            font-size: 1.5em;
            font-weight: bold;
            color: #FF00FF; /* ë„¤ì˜¨ ë§ˆì  íƒ€ */
            margin: 10px 0;
            flex-shrink: 0;
        }
        
        /* ì •ë³´ ë²„íŠ¼ */
        #info-button {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid #fff;
            border-radius: 50%;
            color: white;
            font-size: 1.5em;
            font-weight: bold;
            cursor: pointer;
            z-index: 11;
        }
        
        /* ìƒì„¸ 'ê²Œì„ ë°©ë²•' UI (ëŒ€í­ ìˆ˜ì •) */
        #instructions {
            display: none; /* í‰ì†Œì—” ìˆ¨ê¹€ */
            flex-grow: 1; /* ë‚¨ëŠ” ê³µê°„ì„ ëª¨ë‘ ì°¨ì§€ */
            width: 100%;
            max-width: 400px; /* ê°€ë…ì„± ìœ„í•œ ìµœëŒ€ ë„ˆë¹„ */
            overflow-y: auto; /* *** ì—¬ê¸°ê°€ ìŠ¤í¬ë¡¤ì„ ë‹´ë‹¹ *** */
            text-align: left;
            padding: 10px;
            padding-right: 20px; /* ìŠ¤í¬ë¡¤ë°” ê³µê°„ */
            border-top: 1px solid #50507a;
            border-bottom: 1px solid #50507a;
        }
        
        #instructions h3 {
            color: #00FFFF;
            border-bottom: 1px solid #00FFFF;
            padding-bottom: 5px;
            margin-top: 15px;
            margin-bottom: 10px;
        }
        
        #instructions ul {
            padding-left: 20px;
            margin: 0 0 15px 0;
        }
        
        #instructions li {
            margin-bottom: 10px;
            line-height: 1.5;
        }
        
        #instructions b {
            color: #FFFF00; /* ë…¸ë€ìƒ‰ ê°•ì¡° */
        }
        
        #instructions code {
            background-color: #000;
            padding: 2px 5px;
            border-radius: 3px;
        }
    </style>
</head>
<body>

    <div id="game-container">
        
        <button id="info-button">?</button>

        <div id="top-ui">
            <div id="score">Score: 0</div>
            <div id="level">Lv. 1</div>
        </div>

        <canvas id="game-canvas"></canvas>

        <div id="ui-container">
            <div id="gauge-container">
                <div id="gauge-bar"></div>
            </div>
        </div>
        
        <div id="game-overlay" data-mode="start">
            <div id="overlay-content-wrapper">
                <h1>ğŸ‘» ì—ì½” ì í¼ ğŸ‘»</h1>
                <p id="overlay-message">
                    ì ì˜ ëª¸ì„ ë¹¼ì•—ì•„ ì‹¸ìš°ì„¸ìš”!<br>
                    ìˆ™ì£¼ê°€ íŒŒê´´ë˜ê¸° ì „ì— ë‹¤ìŒ ì ìœ¼ë¡œ 'ì í”„'í•˜ì„¸ìš”.
                </p>
                
                <div id="instructions">
                    <h3>ğŸ•¹ï¸ ì¡°ì‘ ë°©ë²• (Controls)</h3>
                    <h4>ğŸ–¥ï¸ PC (í‚¤ë³´ë“œ + ë§ˆìš°ìŠ¤)</h4>
                    <ul>
                        <li><b>ì´ë™:</b> ë§ˆìš°ìŠ¤ ì»¤ì„œë¥¼ ì›€ì§ì—¬ í•´ë‹¹ ë°©í–¥ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.</li>
                        <li><b>ëŒ€ì‹œ/ë¹™ì˜:</b> <code>ë§ˆìš°ìŠ¤ ì™¼ìª½ í´ë¦­</code>ì„ í•˜ì—¬ ê°€ì¥ ê°€ê¹Œìš´ ì ì—ê²Œ ëŒ€ì‹œ/ë¹™ì˜í•©ë‹ˆë‹¤.</li>
                    </ul>
                    <h4>ğŸ“± ëª¨ë°”ì¼ (í„°ì¹˜ìŠ¤í¬ë¦°)</h4>
                    <ul>
                        <li><b>ì´ë™:</b> í™”ë©´ ì•„ë¬´ ê³³ì´ë‚˜ <code>ì†ê°€ë½ìœ¼ë¡œ ë“œë˜ê·¸</code>í•˜ì—¬ í•´ë‹¹ ë°©í–¥ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.</li>
                        <li><b>ëŒ€ì‹œ/ë¹™ì˜:</b> í™”ë©´ ì•„ë¬´ ê³³ì´ë‚˜ <code>ì§§ê²Œ íƒ­(Tap)</code>í•˜ì—¬ ê°€ì¥ ê°€ê¹Œìš´ ì ì—ê²Œ ëŒ€ì‹œ/ë¹™ì˜í•©ë‹ˆë‹¤.</li>
                    </ul>
                    
                    <h3>1. ê¸°ë³¸ í”Œë ˆì´ ë°©ë²•</h3>
                    <ul>
                        <li>í”Œë ˆì´ì–´ëŠ” ê³µê²© ëŠ¥ë ¥ì´ ì—†ëŠ” <b>'ìœ ë ¹ (ğŸ”µ)'</b> ìƒíƒœë¡œ ì‹œì‘í•©ë‹ˆë‹¤. ìœ ë ¹ ìƒíƒœì—ì„œ ì ê³¼ ë‹¿ìœ¼ë©´ <b>ì¦‰ì‹œ ê²Œì„ ì˜¤ë²„</b>ì…ë‹ˆë‹¤.</li>
                        <li>'ëŒ€ì‹œ'ë¡œ ëª¬ìŠ¤í„°(ì˜ˆ: <code>â—»ï¸</code>)ì—ê²Œ ë‹¿ìœ¼ë©´ <b>'ë¹™ì˜'</b>í•©ë‹ˆë‹¤.</li>
                        <li>ë¹™ì˜ì— ì„±ê³µí•˜ë©´, í”Œë ˆì´ì–´ëŠ” <b>'í‘¸ë¥¸ìƒ‰ ìˆ™ì£¼ (â—»ï¸ğŸ”µ)'</b>ê°€ ë˜ì–´ ëª¬ìŠ¤í„°ë¥¼ ì¡°ì¢…í•˜ë©°, í•´ë‹¹ ëª¬ìŠ¤í„°ì˜ ê³ ìœ  ëŠ¥ë ¥ì´ <b>ìë™ìœ¼ë¡œ ë°œë™</b>ë©ë‹ˆë‹¤.</li>
                        <li>í•˜ë‹¨ì˜ <b>'ë¹™ì˜ ê²Œì´ì§€'</b>ëŠ” <b>ì§€ì†ì ìœ¼ë¡œ ê°ì†Œ</b>í•©ë‹ˆë‹¤. ê²Œì´ì§€ê°€ 0ì´ ë˜ë©´ ìˆ™ì£¼ê°€ íŒŒê´´ë˜ê³  ë‹¹ì‹ ì€ ì ì‹œ ë¬´ì  ìƒíƒœì˜ 'ìœ ë ¹'ì´ ë©ë‹ˆë‹¤.</li>
                        <li><b>'ì í”„':</b> ê²Œì´ì§€ê°€ 0ì´ ë˜ê¸° ì „ì— ë‹¤ì‹œ íƒ­/í´ë¦­í•˜ì—¬ <b>ë‹¤ë¥¸ ëª¬ìŠ¤í„°ë¡œ ê°ˆì•„íƒ€ì•¼</b> í•©ë‹ˆë‹¤. ì´ê²ƒì´ 'ì í”„'ì…ë‹ˆë‹¤.</li>
                    </ul>
                    
                    <h3>2. ëª¬ìŠ¤í„°(ìˆ™ì£¼) íŠ¹ì§•</h3>
                    <ul>
                        <li><b>â—»ï¸ ìŠ¤ì¼ˆë ˆí†¤ (í°ìƒ‰):</b> [ë°¸ëŸ°ìŠ¤í˜•] ê°€ê¹Œìš´ ì ì—ê²Œ ë¼ˆë‹¤ê·€ë¥¼ ë˜ì§‘ë‹ˆë‹¤.</li>
                        <li><b>ğŸŸ© ì¢€ë¹„ (ì´ˆë¡ìƒ‰):</b> [ê´‘ì—­/ë°©ì–´í˜•] ì£¼ë³€ì— 'ë¶€íŒ¨ ì˜¤ë¼'ë¥¼ ë°©ì¶œí•©ë‹ˆë‹¤. ê²Œì´ì§€ê°€ ë§¤ìš° ê¹ë‹ˆë‹¤.</li>
                        <li><b>ğŸŸª ë°•ì¥ (ë³´ë¼ìƒ‰):</b> [ê¸°ë™/ê´€í†µí˜•] ì „ë°©ìœ¼ë¡œ 'ì´ˆìŒíŒŒ'ë¥¼ ì©ë‹ˆë‹¤. ì´ë™ ì†ë„ê°€ ë§¤ìš° ë¹ ë¥´ì§€ë§Œ ê²Œì´ì§€ê°€ ì§§ìŠµë‹ˆë‹¤.</li>
                        <li><b>(ê¸°íƒ€ ëª¬ìŠ¤í„° ìƒëµ...)</b></li>
                    </ul>
                    
                    <h3>3. ê¸°ëŠ¥ (ë ˆë²¨ ì—…)</h3>
                    <ul>
                        <li>ì ì„ ì²˜ì¹˜í•˜ê³  'ì—ì½”(ğŸ’)'ë¥¼ ëª¨ìœ¼ë©´ ë ˆë²¨ ì—… í•©ë‹ˆë‹¤.</li>
                        <li>ë ˆë²¨ ì—… ì‹œ, 3ê°€ì§€ ë¬´ì‘ìœ„ ëŠ¥ë ¥ ì¤‘ í•˜ë‚˜ë¥¼ ì„ íƒí•©ë‹ˆë‹¤. (êµ¬í˜„ ì˜ˆì •)</li>
                    </ul>
                </div>
                
                <p id="final-score"></p>
                <button id="start-button">ì‹œì‘í•˜ê¸°</button>
            </div>
        </div>
        
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            
            // --- DOM ìš”ì†Œ ---
            const gameContainer = document.getElementById('game-container');
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            const gameOverlay = document.getElementById('game-overlay');
            const overlayContent = document.getElementById('overlay-content-wrapper');
            const startButton = document.getElementById('start-button');
            const finalScoreDisplay = document.getElementById('final-score');
            const infoButton = document.getElementById('info-button');
            const instructions = document.getElementById('instructions');
            const overlayMessage = document.getElementById('overlay-message');
            
            const scoreDisplay = document.getElementById('score');
            const levelDisplay = document.getElementById('level');
            const gaugeContainer = document.getElementById('gauge-container');
            const gaugeBar = document.getElementById('gauge-bar');

            // --- ìº”ë²„ìŠ¤ í¬ê¸° ---
            const VIEWPORT_WIDTH = gameContainer.clientWidth;
            const VIEWPORT_HEIGHT = gameContainer.clientHeight;
            canvas.width = VIEWPORT_WIDTH;
            canvas.height = VIEWPORT_HEIGHT;

            // --- ê²Œì„ ìƒíƒœ ë° ì„¤ì • ---
            let gameState = 'start'; // 'start', 'playing', 'over'
            let score = 0;
            let level = 1;
            let gameLoopId = null;
            let frameCount = 0;
            
            let spawnInterval = 180; // 3ì´ˆ (60fps ê¸°ì¤€)
            let nextSpawnFrame = spawnInterval;
            let waveCount = 1; // ìŠ¤í°ë˜ëŠ” ëª¹ ìˆ˜

            let player, enemies, projectiles, echoes;

            // --- ë§ˆìš°ìŠ¤/í„°ì¹˜ ìœ„ì¹˜ ---
            let targetPos = { x: VIEWPORT_WIDTH / 2, y: VIEWPORT_HEIGHT / 2 };

            // --- ëª¬ìŠ¤í„° ì†ì„± ì •ì˜ ---
            const MOB_PROPERTIES = {
                'skeleton': { gauge: 1000, attackType: 'bone', attackCooldown: 50, speed: 2, color: '#FFFFFF', hp: 1 },
                'zombie': { gauge: 2000, attackType: 'aura', attackCooldown: 1, speed: 1.2, color: '#32CD32', hp: 3 },
                'bat': { gauge: 600, attackType: 'sonic', attackCooldown: 30, speed: 3.5, color: '#9400D3', hp: 1 },
            };
            const MOB_TYPES = Object.keys(MOB_PROPERTIES);
            const PLAYER_COLOR = '#00FFFF'; // ë¹™ì˜ ì‹œ í”Œë ˆì´ì–´ ìƒ‰ìƒ

            // --- í”Œë ˆì´ì–´ í´ë˜ìŠ¤ ---
            class Player {
                constructor() {
                    this.x = VIEWPORT_WIDTH / 2;
                    this.y = VIEWPORT_HEIGHT / 2;
                    this.radius = 10;
                    this.state = 'WISP'; // 'WISP', 'HOST', 'UNPOSSESSING' (ë¬´ì  ì‹œê°„)
                    this.hostType = null;
                    this.gauge = 0;
                    this.maxGauge = 0;
                    this.speed = 4; // ìœ ë ¹ ì´ì†
                    this.attackTimer = 0;
                    this.dashCooldown = 0;
                    this.unpossessTimer = 0; // ë¬´ì  ì‹œê°„
                }

                draw() {
                    ctx.shadowBlur = 15; // ë„¤ì˜¨ íš¨ê³¼
                    
                    if (this.state === 'WISP' || this.state === 'UNPOSSESSING') {
                        ctx.fillStyle = PLAYER_COLOR;
                        ctx.shadowColor = PLAYER_COLOR;
                        if(this.unpossessTimer > 0 && frameCount % 10 < 5) {
                             ctx.fillStyle = 'rgba(0, 255, 255, 0.5)'; // ë¬´ì  ê¹œë¹¡ì„
                             ctx.shadowColor = 'rgba(0, 255, 255, 0.5)';
                        }
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (this.state === 'HOST') {
                        ctx.fillStyle = PLAYER_COLOR; // í”Œë ˆì´ì–´ ìƒ‰ìƒìœ¼ë¡œ ê·¸ë¦¼
                        ctx.shadowColor = PLAYER_COLOR;
                        // ëª¬ìŠ¤í„° íƒ€ì…ë³„ë¡œ 'ëª¨ì–‘'ë§Œ ê·¸ë¦¼
                        drawMobShape(ctx, this.hostType, this.x, this.y);
                    }
                    ctx.shadowBlur = 0; // ë„¤ì˜¨ íš¨ê³¼ ë¦¬ì…‹
                }

                update() {
                    if (this.unpossessTimer > 0) {
                        this.unpossessTimer--;
                        if (this.unpossessTimer <= 0) this.state = 'WISP';
                    }
                    if (this.dashCooldown > 0) this.dashCooldown--;

                    // ì´ë™ (ëª©í‘œ ì§€ì ìœ¼ë¡œ ë¶€ë“œëŸ½ê²Œ)
                    const dx = targetPos.x - this.x;
                    const dy = targetPos.y - this.y;
                    const dist = Math.hypot(dx, dy);
                    if (dist > this.speed) {
                        this.x += (dx / dist) * this.speed;
                        this.y += (dy / dist) * this.speed;
                    }
                    
                    // ìˆ™ì£¼ ìƒíƒœ ì—…ë°ì´íŠ¸
                    if (this.state === 'HOST') {
                        this.gauge--;
                        gaugeBar.style.width = `${(this.gauge / this.maxGauge) * 100}%`;
                        
                        if (this.gauge <= 0) this.unpossess();
                        
                        this.attackTimer--;
                        if (this.attackTimer <= 0) this.attack();
                    }
                }
                
                attack() {
                    // (TODO: ëª¬ìŠ¤í„°ë³„ ê³µê²© ë¡œì§)
                }
                
                dash() {
                    if (this.dashCooldown > 0 || this.state === 'HOST') return; // ìœ ë ¹ ìƒíƒœì¼ ë•Œë§Œ ëŒ€ì‹œ ê°€ëŠ¥
                    this.dashCooldown = 30; // 0.5ì´ˆ ì¿¨íƒ€ì„
                    
                    let closestEnemy = null;
                    let minDist = 150; // ëŒ€ì‹œ ìµœëŒ€ ê±°ë¦¬
                    
                    enemies.forEach(enemy => {
                        const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                        if (dist < minDist) {
                            minDist = dist;
                            closestEnemy = enemy;
                        }
                    });
                    
                    if (closestEnemy) {
                        this.possess(closestEnemy);
                    }
                }

                possess(enemy) {
                    this.state = 'HOST';
                    this.hostType = enemy.type;
                    const props = MOB_PROPERTIES[this.hostType];
                    this.maxGauge = props.gauge;
                    this.gauge = this.maxGauge;
                    this.speed = props.speed;
                    this.x = enemy.x; // ìœ„ì¹˜ ë™ê¸°í™”
                    this.y = enemy.y;
                    targetPos.x = this.x; // ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë„ ë™ê¸°í™”
                    targetPos.y = this.y;
                    
                    gaugeContainer.style.display = 'block';
                    enemies = enemies.filter(e => e !== enemy);
                }

                unpossess() {
                    if (this.hostType === 'imp') { /* ... */ }
                    this.state = 'UNPOSSESSING'; // ë¬´ì  ìƒíƒœ
                    this.unpossessTimer = 90; // 1.5ì´ˆ ë¬´ì 
                    this.hostType = null;
                    this.gauge = 0;
                    this.speed = 4; // ìœ ë ¹ ì´ì†
                    gaugeContainer.style.display = 'none';
                }
            }
            
            // ëª¬ìŠ¤í„° í´ë˜ìŠ¤ (ê·¸ë˜í”½ ìˆ˜ì •)
            class Enemy {
                constructor(x, y, type) {
                    this.x = x;
                    this.y = y;
                    this.type = type;
                    this.radius = 12;
                    this.props = MOB_PROPERTIES[type];
                    this.color = this.props.color;
                }
                draw() {
                    ctx.fillStyle = this.color;
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 10;
                    drawMobShape(ctx, this.type, this.x, this.y);
                    ctx.shadowBlur = 0;
                }
                update() {
                    // í”Œë ˆì´ì–´ ë°©í–¥ìœ¼ë¡œ ì²œì²œíˆ ì´ë™
                    const dx = player.x - this.x;
                    const dy = player.y - this.y;
                    const dist = Math.hypot(dx, dy);
                    if (dist > 30) { // ë„ˆë¬´ ê°€ê¹Œìš°ë©´ ë©ˆì¶¤
                        this.x += dx / dist * 0.5; // 0.5 ì†ë„ë¡œ ì´ë™
                        this.y += dy / dist * 0.5;
                    }
                }
            }
            
            // ëª¬ìŠ¤í„° ëª¨ì–‘ ê·¸ë¦¬ê¸° í•¨ìˆ˜ (ìƒˆë¡œ ì¶”ê°€)
            function drawMobShape(ctx, type, x, y) {
                switch(type) {
                    case 'skeleton':
                        ctx.beginPath();
                        ctx.arc(x, y - 8, 8, 0, Math.PI * 2); // ë¨¸ë¦¬
                        ctx.fill();
                        ctx.fillRect(x - 5, y + 2, 10, 12); // ëª¸
                        break;
                    case 'zombie':
                        ctx.beginPath();
                        ctx.moveTo(x - 10, y - 15);
                        ctx.lineTo(x + 10, y - 15);
                        ctx.arcTo(x + 15, y - 15, x + 15, y - 10, 5);
                        ctx.lineTo(x + 15, y + 10);
                        ctx.arcTo(x + 15, y + 15, x + 10, y + 15, 5);
                        ctx.lineTo(x - 10, y + 15);
                        ctx.arcTo(x - 15, y + 15, x - 15, y + 10, 5);
                        ctx.lineTo(x - 15, y - 10);
                        ctx.arcTo(x - 15, y - 15, x - 10, y - 15, 5);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 'bat':
                        ctx.beginPath();
                        ctx.moveTo(x, y + 8);
                        ctx.lineTo(x - 15, y - 8);
                        ctx.lineTo(x - 8, y - 3);
                        ctx.lineTo(x, y - 10);
                        ctx.lineTo(x + 8, y - 3);
                        ctx.lineTo(x + 15, y - 8);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    // (TODO: ë‹¤ë¥¸ ëª¹ ëª¨ì–‘ ì¶”ê°€)
                    default:
                        ctx.beginPath();
                        ctx.arc(x, y, 12, 0, Math.PI * 2);
                        ctx.fill();
                }
            }


            // --- ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ---
            
            // ì‹œì‘ ë²„íŠ¼
            startButton.addEventListener('click', handleStartButton);
            
            // ì •ë³´ ë²„íŠ¼ (ìˆ˜ì •ë¨)
            infoButton.addEventListener('click', () => {
                // ê²Œì„ì´ ì‹œì‘ë˜ì§€ ì•Šì•˜ì„ ë•Œë§Œ ì •ë³´ì°½ í† ê¸€
                if (gameState === 'playing') return;
                
                if (gameOverlay.dataset.mode === 'info') {
                    setupStartScreen(); // ì •ë³´ -> ì‹œì‘
                } else {
                    showInfo(); // ì‹œì‘ -> ì •ë³´
                }
            });
            
            // ì´ë™
            canvas.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                targetPos.x = e.clientX - rect.left;
                targetPos.y = e.clientY - rect.top;
            });
            canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                targetPos.x = e.touches[0].clientX - rect.left;
                targetPos.y = e.touches[0].clientY - rect.top;
            }, { passive: false });
            
            // ëŒ€ì‹œ/ë¹™ì˜
            canvas.addEventListener('mousedown', e => {
                if (gameState === 'playing' && player.state !== 'HOST') player.dash();
            });
            canvas.addEventListener('touchstart', e => {
                if (e.target === canvas && gameState === 'playing' && player.state !== 'HOST') {
                    // ì´ë¯¸ ì´ë™(touchmove)ì´ ì‹œì‘ëœ ê²Œ ì•„ë‹ˆë©´
                    if (e.touches.length === 1) { 
                        player.dash();
                    }
                }
            }, { passive: false });


            // --- í•µì‹¬ í•¨ìˆ˜ ---

            function handleStartButton() {
                if (gameOverlay.dataset.mode === 'info') {
                    setupStartScreen();
                } else {
                    startGame();
                }
            }

            function setupStartScreen(isGameOver = false) {
                gameOverlay.dataset.mode = 'start';
                instructions.style.display = 'none';
                overlayMessage.style.display = 'block';
                finalScoreDisplay.style.display = isGameOver ? 'block' : 'none';
                startButton.textContent = isGameOver ? 'ë‹¤ì‹œí•˜ê¸°' : 'ì‹œì‘í•˜ê¸°';
                gameOverlay.classList.remove('hidden');
            }
            
            function showInfo() {
                gameOverlay.dataset.mode = 'info';
                instructions.style.display = 'block'; 
                overlayMessage.style.display = 'none'; 
                finalScoreDisplay.style.display = 'none';
                startButton.textContent = 'ëŒì•„ê°€ê¸°';
                gameOverlay.classList.remove('hidden');
                
                // *** ìŠ¤í¬ë¡¤ì„ ë§¨ ìœ„ë¡œ ë¦¬ì…‹ (í•µì‹¬ ìˆ˜ì •) ***
                instructions.scrollTop = 0;
            }

            function startGame() {
                score = 0;
                level = 1;
                frameCount = 0;
                waveCount = 1;
                spawnInterval = 180; // 3ì´ˆ
                nextSpawnFrame = 0;
                
                scoreDisplay.textContent = `Score: 0`;
                levelDisplay.textContent = `Lv. 1`;
                
                player = new Player();
                enemies = [];
                projectiles = [];
                echoes = [];

                gameState = 'playing';
                gameOverlay.classList.add('hidden');
                
                gameLoop();
            }

            function endGame() {
                gameState = 'over';
                cancelAnimationFrame(gameLoopId);
                
                finalScoreDisplay.textContent = `ìµœì¢… ì ìˆ˜: ${score}`;
                setupStartScreen(true); // ê²Œì„ ì˜¤ë²„ ìƒíƒœë¡œ ì‹œì‘ í™”ë©´ ì„¤ì •
            }
            
            // ìŠ¤í° ë¡œì§ (ìˆ˜ì •ë¨)
            function spawnEnemies() {
                frameCount++;
                
                if (frameCount > nextSpawnFrame) {
                    for(let i=0; i < waveCount; i++) {
                        const x = Math.random() < 0.5 ? -20 : VIEWPORT_WIDTH + 20;
                        const y = Math.random() * VIEWPORT_HEIGHT;
                        const type = MOB_TYPES[Math.floor(Math.random() * MOB_TYPES.length)];
                        enemies.push(new Enemy(x, y, type));
                    }
                    
                    // ë‹¤ìŒ ìŠ¤í° ê³„ì‚°
                    nextSpawnFrame = frameCount + spawnInterval;
                }
                
                // 30ì´ˆë§ˆë‹¤ ë‚œì´ë„ ìƒìŠ¹
                if (frameCount % 1800 === 0) { // 1800 í”„ë ˆì„ = 30ì´ˆ
                    spawnInterval = Math.max(30, spawnInterval * 0.9); // ìŠ¤í° ê°„ê²© 10% ê°ì†Œ (ìµœì†Œ 0.5ì´ˆ)
                    waveCount = Math.min(10, waveCount + 1); // ìŠ¤í° ëª¹ ìˆ˜ ì¦ê°€ (ìµœëŒ€ 10ë§ˆë¦¬)
                }
            }
            
            function checkCollisions() {
                // 1. ìœ ë ¹ + ì  -> ê²Œì„ ì˜¤ë²„
                if (player.state === 'WISP' && player.unpossessTimer <= 0) {
                    enemies.forEach(enemy => {
                        if (Math.hypot(player.x - enemy.x, player.y - enemy.y) < player.radius + enemy.radius) {
                            endGame();
                        }
                    });
                }
                
                // 2. íˆ¬ì‚¬ì²´ + ì  -> ì  ì£½ìŒ, ì—ì½” ìƒì„±
                // 3. í”Œë ˆì´ì–´ + ì—ì½” -> ì ìˆ˜/ê²½í—˜ì¹˜
            }

            // --- ë©”ì¸ ê²Œì„ ë£¨í”„ ---
            function gameLoop() {
                if (gameState !== 'playing') return;
                gameLoopId = requestAnimationFrame(gameLoop);

                // 1. í´ë¦¬ì–´
                ctx.fillStyle = "#2a2a3e";
                ctx.fillRect(0, 0, VIEWPORT_WIDTH, VIEWPORT_HEIGHT);
                
                // 2. ìƒì„±
                spawnEnemies();
                
                // 3. ì—…ë°ì´íŠ¸
                player.update();
                enemies.forEach(e => e.update());
                // (TODO: projectiles.forEach(p => p.update()));
                // (TODO: echoes.forEach(e => e.update()));
                
                // 4. ì¶©ëŒ
                checkCollisions();
                
                // 5. ê·¸ë¦¬ê¸°
                // (TODO: projectiles.forEach(p => p.draw()));
                // (TODO: echoes.forEach(e => e.draw()));
                enemies.forEach(e => e.draw());
                player.draw(); // í”Œë ˆì´ì–´ë¥¼ ê°€ì¥ ìœ„ì— ê·¸ë¦¬ê¸°
            }
            
            // ì´ˆê¸° í™”ë©´ ì„¤ì •
            setupStartScreen();
        });
    </script>

</body>
</html>
